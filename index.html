<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Advanced AI Fish Evolution - Neural Network Simulator</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.2/gsap.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #0a0e27 0%, #1a1f3a 50%, #2a2f4a 100%);
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            padding: 20px;
            overflow-x: hidden;
        }

        .container {
            background: linear-gradient(135deg, #1a1f3a 0%, #252b4a 100%);
            border-radius: 20px;
            box-shadow: 0 30px 80px rgba(0,0,0,0.8);
            padding: 30px;
            max-width: 1400px;
            width: 100%;
            border: 1px solid rgba(102, 126, 234, 0.3);
        }

        h1 {
            text-align: center;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            margin-bottom: 10px;
            font-size: 2.5em;
            font-weight: 900;
            letter-spacing: -1px;
            text-shadow: 0 0 30px rgba(102, 126, 234, 0.5);
        }

        .subtitle {
            text-align: center;
            color: #a0a8d4;
            margin-bottom: 25px;
            font-size: 1em;
        }

        .main-grid {
            display: grid;
            grid-template-columns: 250px 1fr;
            gap: 20px;
            margin-bottom: 20px;
        }

        .sidebar {
            display: flex;
            flex-direction: column;
            gap: 15px;
        }

        .stats-panel {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            padding: 20px;
            border-radius: 15px;
            color: white;
        }

        .stat-item {
            margin-bottom: 15px;
        }

        .stat-label {
            font-size: 0.75em;
            opacity: 0.9;
            text-transform: uppercase;
            letter-spacing: 1px;
            margin-bottom: 5px;
        }

        .stat-value {
            font-size: 2em;
            font-weight: bold;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.2);
        }

        .neural-viz {
            background: rgba(0, 0, 0, 0.3);
            backdrop-filter: blur(10px);
            border: 2px solid rgba(102, 126, 234, 0.3);
            border-radius: 15px;
            padding: 15px;
            min-height: 200px;
        }

        .neural-title {
            font-size: 0.9em;
            margin-bottom: 10px;
            text-align: center;
            opacity: 0.9;
            color: #fff;
        }

        #neuralCanvas {
            width: 100%;
            height: 180px;
            border-radius: 8px;
            background: rgba(0, 0, 0, 0.2);
        }

        .evolution-log {
            background: rgba(0, 0, 0, 0.4);
            border-radius: 10px;
            padding: 15px;
            max-height: 200px;
            overflow-y: auto;
            font-size: 0.8em;
            color: #e0e0e0;
        }

        .log-entry {
            margin-bottom: 8px;
            padding: 5px;
            background: rgba(102, 126, 234, 0.2);
            border-radius: 5px;
            animation: slideIn 0.3s ease;
            border-left: 3px solid #667eea;
        }

        @keyframes slideIn {
            from {
                opacity: 0;
                transform: translateX(-10px);
            }
            to {
                opacity: 1;
                transform: translateX(0);
            }
        }

        .canvas-container {
            position: relative;
        }

        #gameCanvas {
            width: 100%;
            border: 3px solid #667eea;
            border-radius: 15px;
            background: linear-gradient(180deg, #001220 0%, #003049 50%, #005f73 100%);
            display: block;
            box-shadow: 0 10px 40px rgba(0,0,0,0.3);
        }

        .overlay-stats {
            position: absolute;
            top: 15px;
            right: 15px;
            background: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 15px;
            border-radius: 10px;
            font-size: 0.9em;
            backdrop-filter: blur(10px);
        }

        .controls {
            display: flex;
            gap: 10px;
            justify-content: center;
            flex-wrap: wrap;
            margin-top: 20px;
        }

        button {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            padding: 14px 28px;
            border-radius: 10px;
            font-size: 1em;
            cursor: pointer;
            transition: all 0.3s;
            font-weight: bold;
            box-shadow: 0 4px 15px rgba(102, 126, 234, 0.3);
            position: relative;
            overflow: hidden;
        }

        button::before {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            width: 0;
            height: 0;
            border-radius: 50%;
            background: rgba(255, 255, 255, 0.3);
            transform: translate(-50%, -50%);
            transition: width 0.6s, height 0.6s;
        }

        button:hover::before {
            width: 300px;
            height: 300px;
        }

        button:hover {
            transform: translateY(-3px);
            box-shadow: 0 8px 25px rgba(102, 126, 234, 0.5);
        }

        button:active {
            transform: translateY(-1px);
        }

        .info-panel {
            background: linear-gradient(135deg, #1a1f3a 0%, #252b4a 100%);
            padding: 20px;
            border-radius: 15px;
            margin-top: 20px;
            font-size: 0.95em;
            color: #e0e0e0;
            border: 2px solid rgba(102, 126, 234, 0.3);
        }

        .metrics-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin-top: 15px;
        }

        .metric-card {
            background: rgba(0, 0, 0, 0.3);
            padding: 15px;
            border-radius: 10px;
            text-align: center;
            box-shadow: 0 4px 10px rgba(0,0,0,0.3);
            border: 1px solid rgba(102, 126, 234, 0.2);
        }

        .metric-label {
            font-size: 0.8em;
            color: #a0a8d4;
            margin-bottom: 5px;
        }

        .metric-value {
            font-size: 1.5em;
            font-weight: bold;
            color: #667eea;
        }

        .progress-bar {
            width: 100%;
            height: 8px;
            background: rgba(255, 255, 255, 0.3);
            border-radius: 4px;
            overflow: hidden;
            margin-top: 10px;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #667eea 0%, #764ba2 100%);
            transition: width 0.3s ease;
        }

        @media (max-width: 1200px) {
            .main-grid {
                grid-template-columns: 1fr;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>üê† ADVANCED AI FISH EVOLUTION</h1>
        <p class="subtitle">Deep Neural Networks ‚Ä¢ Genetic Algorithms ‚Ä¢ Real-time Evolution ‚Ä¢ GSAP Animations</p>
        
        <div class="main-grid">
            <div class="sidebar">
                <div class="stats-panel">
                    <div class="stat-item">
                        <div class="stat-label">Generation</div>
                        <div class="stat-value" id="generation">1</div>
                        <div class="progress-bar">
                            <div class="progress-fill" id="genProgress" style="width: 0%"></div>
                        </div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-label">Population</div>
                        <div class="stat-value"><span id="alive">20</span>/<span id="total">20</span></div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-label">Best Fitness</div>
                        <div class="stat-value" id="bestFitness">0</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-label">Avg Fitness</div>
                        <div class="stat-value" id="avgFitness">0</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-label">Mutation Rate</div>
                        <div class="stat-value" id="mutationRate">15%</div>
                    </div>
                </div>

                <div class="stats-panel">
                    <div class="neural-title">üß† Best Brain Activity</div>
                    <canvas id="neuralCanvas" width="220" height="180"></canvas>
                </div>

                <div class="stats-panel">
                    <div class="neural-title">üìú Evolution Log</div>
                    <div class="evolution-log" id="evolutionLog">
                        <div class="log-entry">üöÄ Simulation initialized</div>
                    </div>
                </div>
            </div>

            <div class="canvas-container">
                <canvas id="gameCanvas" width="1100" height="700"></canvas>
                <div class="overlay-stats">
                    <div>‚ö° Lasers: <span id="laserCount">0</span></div>
                    <div>üíÄ Deaths: <span id="deathCount">0</span></div>
                    <div>‚è±Ô∏è Time: <span id="timeAlive">0</span>s</div>
                </div>
            </div>
        </div>

        <div class="controls">
            <button id="startBtn">‚ñ∂Ô∏è Start Evolution</button>
            <button id="pauseBtn">‚è∏Ô∏è Pause</button>
            <button id="speedBtn">‚ö° Speed: 1x</button>
            <button id="resetBtn">üîÑ Reset</button>
            <button id="spawnLaserBtn">üî¥ Spawn Laser</button>
        </div>

        <div class="info-panel">
            <strong>üß¨ Advanced Evolution System:</strong> Each fish has a deep neural network (8‚Üí16‚Üí8‚Üí2) that processes laser positions, velocities, distances, and angles. The genetic algorithm uses tournament selection, elitism, crossover, and adaptive mutation. Watch as fish evolve complex dodging behaviors over generations!
            
            <div class="metrics-grid">
                <div class="metric-card">
                    <div class="metric-label">All-Time Best</div>
                    <div class="metric-value" id="allTimeBest">0</div>
                </div>
                <div class="metric-card">
                    <div class="metric-label">Best Generation</div>
                    <div class="metric-value" id="bestGen">1</div>
                </div>
                <div class="metric-card">
                    <div class="metric-label">Total Deaths</div>
                    <div class="metric-value" id="totalDeaths">0</div>
                </div>
                <div class="metric-card">
                    <div class="metric-label">Avg Lifespan</div>
                    <div class="metric-value" id="avgLifespan">0</div>
                </div>
            </div>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const neuralCanvas = document.getElementById('neuralCanvas');
        const neuralCtx = neuralCanvas.getContext('2d');

        // Enhanced game state
        let generation = 1;
        let population = [];
        let lasers = [];
        let particles = [];
        let isRunning = false;
        let isPaused = false;
        let speedMultiplier = 1;
        let frameCount = 0;
        let bestFitnessEver = 0;
        let bestGenerationEver = 1;
        let totalDeaths = 0;
        let deathsThisGen = 0;
        let lifespanHistory = [];

        const CONFIG = {
            POPULATION_SIZE: 30,
            MUTATION_RATE: 0.08,
            LASER_SPAWN_RATE: 0.008,
            MAX_LASERS: 8,
            ELITE_COUNT: 6,
            TOURNAMENT_SIZE: 7,
            CROSSOVER_RATE: 0.8,
            MAX_GENERATION_TIME: 8000
        };

        // Particle effect class
        class Particle {
            constructor(x, y, color) {
                this.x = x;
                this.y = y;
                this.vx = (Math.random() - 0.5) * 8;
                this.vy = (Math.random() - 0.5) * 8;
                this.size = Math.random() * 4 + 2;
                this.life = 1;
                this.color = color;
                this.decay = Math.random() * 0.02 + 0.01;
            }

            update() {
                this.x += this.vx;
                this.y += this.vy;
                this.vy += 0.2; // gravity
                this.life -= this.decay;
                this.size *= 0.96;
            }

            draw() {
                ctx.save();
                ctx.globalAlpha = this.life;
                ctx.fillStyle = this.color;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
                ctx.fill();
                ctx.restore();
            }

            isDead() {
                return this.life <= 0;
            }
        }

        // Advanced Neural Network with multiple layers
        class AdvancedNeuralNetwork {
            constructor(layers = [10, 20, 12, 2]) {
                this.layers = layers;
                this.weights = [];
                this.biases = [];
                
                for (let i = 0; i < layers.length - 1; i++) {
                    this.weights.push(this.randomMatrix(layers[i], layers[i + 1]));
                    this.biases.push(this.randomArray(layers[i + 1]));
                }
            }

            randomMatrix(rows, cols) {
                // Xavier initialization for better training
                const scale = Math.sqrt(2.0 / (rows + cols));
                return Array(rows).fill().map(() => 
                    Array(cols).fill().map(() => (Math.random() * 2 - 1) * scale)
                );
            }

            randomArray(size) {
                return Array(size).fill().map(() => Math.random() * 2 - 1);
            }

            activate(x, type = 'tanh') {
                if (type === 'tanh') return Math.tanh(x);
                if (type === 'relu') return Math.max(0, x);
                if (type === 'sigmoid') return 1 / (1 + Math.exp(-x));
                return x;
            }

            predict(inputs) {
                let activations = inputs;
                
                for (let i = 0; i < this.weights.length; i++) {
                    let nextActivations = [];
                    
                    for (let j = 0; j < this.weights[i][0].length; j++) {
                        let sum = this.biases[i][j];
                        for (let k = 0; k < activations.length; k++) {
                            sum += activations[k] * this.weights[i][k][j];
                        }
                        // Use ReLU for hidden layers, tanh for output
                        const activation = i === this.weights.length - 1 ? 'tanh' : 'relu';
                        nextActivations.push(this.activate(sum, activation));
                    }
                    
                    activations = nextActivations;
                }
                
                return activations;
            }

            mutate(rate) {
                for (let i = 0; i < this.weights.length; i++) {
                    for (let j = 0; j < this.weights[i].length; j++) {
                        for (let k = 0; k < this.weights[i][j].length; k++) {
                            if (Math.random() < rate) {
                                // Gaussian mutation
                                this.weights[i][j][k] += this.gaussian() * 0.3;
                            }
                        }
                    }
                    
                    for (let j = 0; j < this.biases[i].length; j++) {
                        if (Math.random() < rate) {
                            this.biases[i][j] += this.gaussian() * 0.3;
                        }
                    }
                }
            }

            gaussian() {
                // Box-Muller transform for Gaussian distribution
                const u1 = Math.random();
                const u2 = Math.random();
                return Math.sqrt(-2 * Math.log(u1)) * Math.cos(2 * Math.PI * u2);
            }

            crossover(other) {
                const child = new AdvancedNeuralNetwork(this.layers);
                
                for (let i = 0; i < this.weights.length; i++) {
                    for (let j = 0; j < this.weights[i].length; j++) {
                        for (let k = 0; k < this.weights[i][j].length; k++) {
                            child.weights[i][j][k] = Math.random() < 0.5 ? 
                                this.weights[i][j][k] : other.weights[i][j][k];
                        }
                    }
                    
                    for (let j = 0; j < this.biases[i].length; j++) {
                        child.biases[i][j] = Math.random() < 0.5 ? 
                            this.biases[i][j] : other.biases[i][j];
                    }
                }
                
                return child;
            }

            copy() {
                const nn = new AdvancedNeuralNetwork(this.layers);
                nn.weights = this.weights.map(w => w.map(row => [...row]));
                nn.biases = this.biases.map(b => [...b]);
                return nn;
            }
        }

        // Enhanced Fish class with better AI
        class Fish {
            constructor(brain = null) {
                this.x = canvas.width / 2 + (Math.random() - 0.5) * 200;
                this.y = canvas.height / 2 + (Math.random() - 0.5) * 200;
                this.vx = 0;
                this.vy = 0;
                this.ax = 0;
                this.ay = 0;
                this.size = 18;
                this.alive = true;
                this.fitness = 0;
                this.brain = brain || new AdvancedNeuralNetwork([10, 20, 12, 2]);
                this.hue = Math.random() * 360;
                this.saturation = 70 + Math.random() * 30;
                this.lightness = 50 + Math.random() * 20;
                this.color = `hsl(${this.hue}, ${this.saturation}%, ${this.lightness}%)`;
                this.tailAngle = 0;
                this.nearMisses = 0;
                this.distanceTraveled = 0;
                this.lastInputs = [];
                this.survivalTime = 0;
            }

            think(lasers) {
                // Find 2 closest lasers with velocity and trajectory info
                const closestLasers = lasers
                    .map(laser => {
                        const dx = laser.x - this.x;
                        const dy = laser.y - this.y;
                        const dist = Math.hypot(dx, dy);
                        
                        // Predict future collision
                        const relVx = laser.vx;
                        const relVy = laser.vy;
                        const timeToCollision = dist / Math.hypot(relVx, relVy);
                        const futureX = laser.x + relVx * timeToCollision;
                        const futureY = laser.y + relVy * timeToCollision;
                        const futureDist = Math.hypot(futureX - this.x, futureY - this.y);
                        
                        return {
                            laser,
                            dist,
                            dx,
                            dy,
                            futureDist,
                            danger: dist < 200 ? (200 - dist) / 200 : 0
                        };
                    })
                    .sort((a, b) => a.dist - b.dist)
                    .slice(0, 2);

                let inputs = [];
                
                // Add detailed info for each of the 2 closest lasers
                for (let i = 0; i < 2; i++) {
                    if (closestLasers[i]) {
                        const laser = closestLasers[i].laser;
                        const dx = closestLasers[i].dx;
                        const dy = closestLasers[i].dy;
                        const dist = closestLasers[i].dist;
                        
                        // Normalized distance (inverse for danger signal)
                        inputs.push(1 - Math.min(dist / 400, 1));
                        
                        // Direction to laser (normalized)
                        inputs.push(dx / 400);
                        inputs.push(dy / 400);
                        
                        // Laser velocity (normalized)
                        inputs.push(laser.vx / 5);
                        inputs.push(laser.vy / 5);
                        
                        // Check for near miss
                        if (dist < this.size + 40) {
                            this.nearMisses++;
                        }
                    } else {
                        inputs.push(0, 0, 0, 0, 0);
                    }
                }

                // Add fish's own state
                inputs.push(this.x / canvas.width);
                inputs.push(this.y / canvas.height);
                inputs.push(this.vx / 6);
                inputs.push(this.vy / 6);

                // Ensure exactly 10 inputs (2 lasers √ó 5 + own state √ó 4)
                while (inputs.length < 10) inputs.push(0);
                inputs = inputs.slice(0, 10);

                this.lastInputs = inputs;
                
                const output = this.brain.predict(inputs);
                
                // Apply stronger forces for better responsiveness
                this.ax = output[0] * 0.8;
                this.ay = output[1] * 0.8;
            }

            update() {
                if (!this.alive) return;

                const oldX = this.x;
                const oldY = this.y;

                // Apply acceleration
                this.vx += this.ax;
                this.vy += this.ay;

                // Apply drag
                this.vx *= 0.92;
                this.vy *= 0.92;

                // Limit max speed
                const maxSpeed = 7;
                const speed = Math.hypot(this.vx, this.vy);
                if (speed > maxSpeed) {
                    this.vx = (this.vx / speed) * maxSpeed;
                    this.vy = (this.vy / speed) * maxSpeed;
                }

                this.x += this.vx;
                this.y += this.vy;

                // Track distance traveled
                this.distanceTraveled += Math.hypot(this.x - oldX, this.y - oldY);

                // Soft boundaries with gradual pushback
                const margin = 50;
                if (this.x < margin) this.vx += (margin - this.x) * 0.02;
                if (this.x > canvas.width - margin) this.vx -= (this.x - (canvas.width - margin)) * 0.02;
                if (this.y < margin) this.vy += (margin - this.y) * 0.02;
                if (this.y > canvas.height - margin) this.vy -= (this.y - (canvas.height - margin)) * 0.02;

                // Clamp position
                this.x = Math.max(this.size, Math.min(canvas.width - this.size, this.x));
                this.y = Math.max(this.size, Math.min(canvas.height - this.size, this.y));

                this.survivalTime++;

                // Improved fitness: exponential survival reward + near miss bonus
                this.fitness = Math.pow(this.survivalTime, 1.5) + (this.nearMisses * 50) + (this.distanceTraveled * 0.02);
                
                // Animate tail
                this.tailAngle += 0.15;
            }

            draw() {
                if (!this.alive) return;

                ctx.save();
                ctx.translate(this.x, this.y);
                
                const angle = Math.atan2(this.vy, this.vx);
                ctx.rotate(angle);

                // Fish glow/aura
                const gradient = ctx.createRadialGradient(0, 0, 0, 0, 0, this.size * 2);
                gradient.addColorStop(0, `hsla(${this.hue}, ${this.saturation}%, ${this.lightness}%, 0.3)`);
                gradient.addColorStop(1, `hsla(${this.hue}, ${this.saturation}%, ${this.lightness}%, 0)`);
                ctx.fillStyle = gradient;
                ctx.beginPath();
                ctx.arc(0, 0, this.size * 2, 0, Math.PI * 2);
                ctx.fill();

                // Fish body (more detailed)
                ctx.fillStyle = this.color;
                ctx.strokeStyle = `hsl(${this.hue}, ${this.saturation}%, ${this.lightness - 20}%)`;
                ctx.lineWidth = 2;
                
                ctx.beginPath();
                ctx.ellipse(0, 0, this.size * 1.2, this.size * 0.7, 0, 0, Math.PI * 2);
                ctx.fill();
                ctx.stroke();

                // Dorsal fin
                ctx.beginPath();
                ctx.moveTo(-this.size * 0.3, -this.size * 0.7);
                ctx.lineTo(0, -this.size * 1.3);
                ctx.lineTo(this.size * 0.3, -this.size * 0.7);
                ctx.closePath();
                ctx.fill();
                ctx.stroke();

                // Tail with animation
                const tailWave = Math.sin(this.tailAngle) * 0.3;
                ctx.beginPath();
                ctx.moveTo(-this.size * 1.2, 0);
                ctx.lineTo(-this.size * 1.8, -this.size * 0.6 + tailWave);
                ctx.lineTo(-this.size * 1.8, this.size * 0.6 + tailWave);
                ctx.closePath();
                ctx.fill();
                ctx.stroke();

                // Pectoral fins
                ctx.beginPath();
                ctx.ellipse(this.size * 0.2, this.size * 0.5, this.size * 0.4, this.size * 0.2, 0.5, 0, Math.PI * 2);
                ctx.fill();
                ctx.stroke();

                ctx.beginPath();
                ctx.ellipse(this.size * 0.2, -this.size * 0.5, this.size * 0.4, this.size * 0.2, -0.5, 0, Math.PI * 2);
                ctx.fill();
                ctx.stroke();

                // Eye
                ctx.fillStyle = 'white';
                ctx.beginPath();
                ctx.arc(this.size * 0.6, -this.size * 0.3, this.size * 0.2, 0, Math.PI * 2);
                ctx.fill();
                
                ctx.fillStyle = 'black';
                ctx.beginPath();
                ctx.arc(this.size * 0.7, -this.size * 0.3, this.size * 0.1, 0, Math.PI * 2);
                ctx.fill();

                // Eye shine
                ctx.fillStyle = 'white';
                ctx.beginPath();
                ctx.arc(this.size * 0.75, -this.size * 0.35, this.size * 0.05, 0, Math.PI * 2);
                ctx.fill();

                ctx.restore();

                // Draw velocity vector for debugging (optional)
                if (speedMultiplier > 1) {
                    ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
                    ctx.lineWidth = 1;
                    ctx.beginPath();
                    ctx.moveTo(this.x, this.y);
                    ctx.lineTo(this.x + this.vx * 10, this.y + this.vy * 10);
                    ctx.stroke();
                }
            }

            die() {
                this.alive = false;
                totalDeaths++;
                deathsThisGen++;
                
                // Create death particles with GSAP
                for (let i = 0; i < 20; i++) {
                    const particle = new Particle(this.x, this.y, this.color);
                    particles.push(particle);
                    
                    // GSAP animation for particles
                    gsap.to(particle, {
                        x: particle.x + particle.vx * 20,
                        y: particle.y + particle.vy * 20,
                        duration: 1,
                        ease: "power2.out"
                    });
                }
            }
        }

        // Enhanced Laser class with better graphics
        class Laser {
            constructor(x = null, y = null) {
                if (x === null || y === null) {
                    const side = Math.floor(Math.random() * 4);
                    if (side === 0) { // Top
                        this.x = Math.random() * canvas.width;
                        this.y = -20;
                    } else if (side === 1) { // Right
                        this.x = canvas.width + 20;
                        this.y = Math.random() * canvas.height;
                    } else if (side === 2) { // Bottom
                        this.x = Math.random() * canvas.width;
                        this.y = canvas.height + 20;
                    } else { // Left
                        this.x = -20;
                        this.y = Math.random() * canvas.height;
                    }

                    // Target center with some randomness
                    const targetX = canvas.width / 2 + (Math.random() - 0.5) * 300;
                    const targetY = canvas.height / 2 + (Math.random() - 0.5) * 300;
                    const angle = Math.atan2(targetY - this.y, targetX - this.x);
                    const speed = 2.5 + Math.random() * 2;
                    this.vx = Math.cos(angle) * speed;
                    this.vy = Math.sin(angle) * speed;
                } else {
                    this.x = x;
                    this.y = y;
                    const angle = Math.random() * Math.PI * 2;
                    const speed = 3 + Math.random() * 2;
                    this.vx = Math.cos(angle) * speed;
                    this.vy = Math.sin(angle) * speed;
                }

                this.radius = 10;
                this.trail = [];
                this.glowIntensity = 0;
                
                // GSAP pulsing animation
                gsap.to(this, {
                    glowIntensity: 1,
                    duration: 0.5,
                    repeat: -1,
                    yoyo: true,
                    ease: "power1.inOut"
                });
            }

            update() {
                this.trail.push({ x: this.x, y: this.y });
                if (this.trail.length > 15) this.trail.shift();

                this.x += this.vx;
                this.y += this.vy;

                // Slight homing behavior towards center
                const centerX = canvas.width / 2;
                const centerY = canvas.height / 2;
                const angleToCenter = Math.atan2(centerY - this.y, centerX - this.x);
                const currentAngle = Math.atan2(this.vy, this.vx);
                const angleDiff = angleToCenter - currentAngle;
                
                this.vx += Math.cos(currentAngle + angleDiff * 0.02) * 0.05;
                this.vy += Math.sin(currentAngle + angleDiff * 0.02) * 0.05;
            }

            draw() {
                // Draw trail
                ctx.save();
                for (let i = 0; i < this.trail.length; i++) {
                    const alpha = (i / this.trail.length) * 0.5;
                    const size = (i / this.trail.length) * this.radius;
                    
                    ctx.fillStyle = `rgba(255, 50, 50, ${alpha})`;
                    ctx.beginPath();
                    ctx.arc(this.trail[i].x, this.trail[i].y, size, 0, Math.PI * 2);
                    ctx.fill();
                }

                // Outer glow
                const glowSize = this.radius * (3 + this.glowIntensity);
                const gradient = ctx.createRadialGradient(this.x, this.y, 0, this.x, this.y, glowSize);
                gradient.addColorStop(0, 'rgba(255, 0, 0, 0.8)');
                gradient.addColorStop(0.3, 'rgba(255, 50, 0, 0.5)');
                gradient.addColorStop(0.7, 'rgba(255, 100, 0, 0.2)');
                gradient.addColorStop(1, 'rgba(255, 150, 0, 0)');
                
                ctx.fillStyle = gradient;
                ctx.beginPath();
                ctx.arc(this.x, this.y, glowSize, 0, Math.PI * 2);
                ctx.fill();

                // Inner core
                ctx.fillStyle = '#ff0000';
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                ctx.fill();

                // Highlight
                ctx.fillStyle = '#ff6666';
                ctx.beginPath();
                ctx.arc(this.x - this.radius * 0.3, this.y - this.radius * 0.3, this.radius * 0.4, 0, Math.PI * 2);
                ctx.fill();

                // Energy ring
                ctx.strokeStyle = `rgba(255, 200, 0, ${0.5 + this.glowIntensity * 0.5})`;
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.radius * 1.5, 0, Math.PI * 2);
                ctx.stroke();

                ctx.restore();
            }

            isOffScreen() {
                return this.x < -100 || this.x > canvas.width + 100 || 
                       this.y < -100 || this.y > canvas.height + 100;
            }
        }

        // Initialize population
        function initPopulation() {
            population = [];
            for (let i = 0; i < CONFIG.POPULATION_SIZE; i++) {
                population.push(new Fish());
            }
            lasers = [];
            particles = [];
            frameCount = 0;
            deathsThisGen = 0;
            
            addLog(`üê† Generation ${generation} spawned with ${CONFIG.POPULATION_SIZE} fish`);
        }

        // Tournament selection
        function tournamentSelect(pop, tournamentSize) {
            const tournament = [];
            for (let i = 0; i < tournamentSize; i++) {
                tournament.push(pop[Math.floor(Math.random() * pop.length)]);
            }
            tournament.sort((a, b) => b.fitness - a.fitness);
            return tournament[0];
        }

        // Check collisions
        function checkCollisions() {
            population.forEach(fish => {
                if (!fish.alive) return;
                
                lasers.forEach(laser => {
                    const dist = Math.hypot(laser.x - fish.x, laser.y - fish.y);
                    if (dist < fish.size + laser.radius) {
                        fish.die();
                    }
                });
            });
        }

        // Evolve to next generation
        function evolvePopulation() {
            population.sort((a, b) => b.fitness - a.fitness);

            const bestFitness = population[0].fitness;
            const avgFitness = Math.round(population.reduce((sum, f) => sum + f.fitness, 0) / population.length);
            
            lifespanHistory.push(avgFitness);
            if (lifespanHistory.length > 50) lifespanHistory.shift();

            if (bestFitness > bestFitnessEver) {
                bestFitnessEver = Math.round(bestFitness);
                bestGenerationEver = generation;
                document.getElementById('allTimeBest').textContent = bestFitnessEver;
                document.getElementById('bestGen').textContent = bestGenerationEver;
                
                addLog(`üèÜ NEW RECORD! Fitness: ${bestFitnessEver} in Gen ${generation}`);
                
                // GSAP celebration animation
                gsap.fromTo('#allTimeBest', 
                    { scale: 1, color: '#667eea' },
                    { scale: 1.5, color: '#ff6b6b', duration: 0.5, yoyo: true, repeat: 1 }
                );
            }

            addLog(`üìä Gen ${generation}: Best=${Math.round(bestFitness)}, Avg=${avgFitness}, Deaths=${deathsThisGen}`);

            const newPopulation = [];
            
            // Elitism - keep best performers
            for (let i = 0; i < CONFIG.ELITE_COUNT; i++) {
                newPopulation.push(new Fish(population[i].brain.copy()));
            }

            // Create rest through tournament selection, crossover, and mutation
            while (newPopulation.length < CONFIG.POPULATION_SIZE) {
                const parent1 = tournamentSelect(population, CONFIG.TOURNAMENT_SIZE);
                
                let childBrain;
                
                if (Math.random() < CONFIG.CROSSOVER_RATE) {
                    const parent2 = tournamentSelect(population, CONFIG.TOURNAMENT_SIZE);
                    childBrain = parent1.brain.crossover(parent2.brain);
                } else {
                    childBrain = parent1.brain.copy();
                }
                
                // Adaptive mutation: lower for good performers, higher if stagnating
                let mutRate = CONFIG.MUTATION_RATE;
                if (generation - bestGenerationEver > 20) {
                    mutRate *= 1.5; // Increase exploration if stuck
                } else if (bestFitness > avgFitness * 2) {
                    mutRate *= 0.5; // Decrease mutation for stable good performers
                }
                
                childBrain.mutate(Math.min(mutRate, 0.4));
                
                newPopulation.push(new Fish(childBrain));
            }

            population = newPopulation;
            lasers = [];
            particles = [];
            generation++;
            frameCount = 0;
            deathsThisGen = 0;
            
            // Calculate and display current mutation rate
            let displayMutRate = CONFIG.MUTATION_RATE;
            if (generation - bestGenerationEver > 20) {
                displayMutRate *= 1.5;
            } else if (bestFitness > avgFitness * 2) {
                displayMutRate *= 0.5;
            }
            document.getElementById('mutationRate').textContent = 
                Math.round(Math.min(displayMutRate, 0.4) * 100) + '%';
        }

        // Update stats with GSAP animations
        function updateStats() {
            const alive = population.filter(f => f.alive).length;
            const bestFitness = Math.round(Math.max(...population.map(f => f.fitness)));
            const avgFitness = Math.round(population.reduce((sum, f) => sum + f.fitness, 0) / population.length);

            // Animate stat changes
            gsap.to('#generation', { innerHTML: generation, duration: 0.3, snap: { innerHTML: 1 } });
            gsap.to('#alive', { innerHTML: alive, duration: 0.2, snap: { innerHTML: 1 } });
            gsap.to('#total', { innerHTML: CONFIG.POPULATION_SIZE, duration: 0.2 });
            gsap.to('#bestFitness', { innerHTML: bestFitness, duration: 0.3, snap: { innerHTML: 1 } });
            gsap.to('#avgFitness', { innerHTML: avgFitness, duration: 0.3, snap: { innerHTML: 1 } });
            
            document.getElementById('laserCount').textContent = lasers.length;
            document.getElementById('deathCount').textContent = deathsThisGen;
            document.getElementById('timeAlive').textContent = Math.round(frameCount / 60);
            document.getElementById('totalDeaths').textContent = totalDeaths;
            
            const avgLifespan = lifespanHistory.length > 0 
                ? Math.round(lifespanHistory.reduce((a, b) => a + b, 0) / lifespanHistory.length)
                : 0;
            document.getElementById('avgLifespan').textContent = avgLifespan;

            // Progress bar animation
            const progress = Math.min((frameCount / CONFIG.MAX_GENERATION_TIME) * 100, 100);
            gsap.to('#genProgress', { width: progress + '%', duration: 0.1 });
        }

        // Draw neural network visualization
        function drawNeuralNetwork() {
            const bestFish = population.reduce((best, fish) => 
                fish.fitness > best.fitness ? fish : best, population[0]
            );

            if (!bestFish || !bestFish.alive) return;

            neuralCtx.clearRect(0, 0, neuralCanvas.width, neuralCanvas.height);
            
            const layers = bestFish.brain.layers;
            const nodeRadius = 6;
            const layerSpacing = neuralCanvas.width / (layers.length + 1);
            
            // Draw connections with weights
            for (let l = 0; l < layers.length - 1; l++) {
                const x1 = layerSpacing * (l + 1);
                const x2 = layerSpacing * (l + 2);
                const nodeSpacing1 = neuralCanvas.height / (layers[l] + 1);
                const nodeSpacing2 = neuralCanvas.height / (layers[l + 1] + 1);
                
                for (let i = 0; i < Math.min(layers[l], 8); i++) {
                    for (let j = 0; j < Math.min(layers[l + 1], 8); j++) {
                        const y1 = nodeSpacing1 * (i + 1);
                        const y2 = nodeSpacing2 * (j + 1);
                        
                        const weight = bestFish.brain.weights[l][i] ? bestFish.brain.weights[l][i][j] : 0;
                        const alpha = Math.abs(weight) * 0.5;
                        const color = weight > 0 ? `rgba(102, 126, 234, ${alpha})` : `rgba(234, 102, 102, ${alpha})`;
                        
                        neuralCtx.strokeStyle = color;
                        neuralCtx.lineWidth = Math.abs(weight) * 2;
                        neuralCtx.beginPath();
                        neuralCtx.moveTo(x1, y1);
                        neuralCtx.lineTo(x2, y2);
                        neuralCtx.stroke();
                    }
                }
            }
            
            // Draw nodes
            for (let l = 0; l < layers.length; l++) {
                const x = layerSpacing * (l + 1);
                const nodeCount = Math.min(layers[l], 8);
                const nodeSpacing = neuralCanvas.height / (nodeCount + 1);
                
                for (let i = 0; i < nodeCount; i++) {
                    const y = nodeSpacing * (i + 1);
                    
                    // Node activation (simplified)
                    let activation = 0.5;
                    if (l === 0 && bestFish.lastInputs[i] !== undefined) {
                        activation = Math.abs(bestFish.lastInputs[i]);
                    }
                    
                    const gradient = neuralCtx.createRadialGradient(x, y, 0, x, y, nodeRadius);
                    gradient.addColorStop(0, `hsla(${270 - activation * 120}, 70%, ${50 + activation * 30}%, 1)`);
                    gradient.addColorStop(1, `hsla(${270 - activation * 120}, 70%, ${30 + activation * 20}%, 1)`);
                    
                    neuralCtx.fillStyle = gradient;
                    neuralCtx.beginPath();
                    neuralCtx.arc(x, y, nodeRadius, 0, Math.PI * 2);
                    neuralCtx.fill();
                    
                    neuralCtx.strokeStyle = 'white';
                    neuralCtx.lineWidth = 1;
                    neuralCtx.stroke();
                }
            }
        }

        // Add log entry
        function addLog(message) {
            const logContainer = document.getElementById('evolutionLog');
            const entry = document.createElement('div');
            entry.className = 'log-entry';
            entry.textContent = message;
            logContainer.insertBefore(entry, logContainer.firstChild);
            
            // Keep only last 20 entries
            while (logContainer.children.length > 20) {
                logContainer.removeChild(logContainer.lastChild);
            }
            
            // GSAP animation
            gsap.from(entry, { opacity: 0, x: -20, duration: 0.3 });
        }

        // Main game loop
        function gameLoop() {
            if (!isRunning || isPaused) {
                requestAnimationFrame(gameLoop);
                return;
            }

            for (let speed = 0; speed < speedMultiplier; speed++) {
                // Spawn lasers
                if (lasers.length < CONFIG.MAX_LASERS && Math.random() < CONFIG.LASER_SPAWN_RATE) {
                    lasers.push(new Laser());
                }

                // Update lasers
                lasers = lasers.filter(laser => {
                    laser.update();
                    return !laser.isOffScreen();
                });

                // Update particles
                particles = particles.filter(p => {
                    p.update();
                    return !p.isDead();
                });

                // Update fish
                population.forEach(fish => {
                    if (fish.alive) {
                        fish.think(lasers);
                        fish.update();
                    }
                });

                checkCollisions();
                frameCount++;

                // Check if generation should end
                const allDead = population.every(f => !f.alive);
                if (allDead || frameCount > CONFIG.MAX_GENERATION_TIME) {
                    evolvePopulation();
                }
            }

            // Clear with fade effect
            ctx.fillStyle = 'rgba(0, 18, 32, 0.15)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Draw water effect
            ctx.save();
            ctx.globalAlpha = 0.1;
            for (let i = 0; i < 3; i++) {
                ctx.fillStyle = `hsl(200, 70%, ${40 + i * 10}%)`;
                ctx.fillRect(0, i * canvas.height / 3, canvas.width, canvas.height / 3);
            }
            ctx.restore();

            // Draw particles
            particles.forEach(p => p.draw());

            // Draw lasers
            lasers.forEach(laser => laser.draw());

            // Draw fish
            population.forEach(fish => fish.draw());

            // Update UI
            updateStats();
            drawNeuralNetwork();

            requestAnimationFrame(gameLoop);
        }

        // Controls
        document.getElementById('startBtn').addEventListener('click', () => {
            if (!isRunning) {
                isRunning = true;
                isPaused = false;
                addLog('üöÄ Evolution started!');
                gameLoop();
                
                gsap.from('.container', { scale: 0.98, duration: 0.3, ease: "back.out" });
            }
        });

        document.getElementById('pauseBtn').addEventListener('click', () => {
            isPaused = !isPaused;
            document.getElementById('pauseBtn').textContent = isPaused ? '‚ñ∂Ô∏è Resume' : '‚è∏Ô∏è Pause';
            addLog(isPaused ? '‚è∏Ô∏è Paused' : '‚ñ∂Ô∏è Resumed');
            
            if (!isPaused) {
                gsap.from('#pauseBtn', { scale: 1.2, duration: 0.2 });
            }
        });

        document.getElementById('speedBtn').addEventListener('click', () => {
            const speeds = [1, 2, 4, 8];
            const currentIndex = speeds.indexOf(speedMultiplier);
            speedMultiplier = speeds[(currentIndex + 1) % speeds.length];
            document.getElementById('speedBtn').textContent = `‚ö° Speed: ${speedMultiplier}x`;
            addLog(`‚ö° Speed changed to ${speedMultiplier}x`);
            
            gsap.from('#speedBtn', { rotation: 360, duration: 0.5, ease: "back.out" });
        });

        document.getElementById('resetBtn').addEventListener('click', () => {
            generation = 1;
            bestFitnessEver = 0;
            bestGenerationEver = 1;
            totalDeaths = 0;
            lifespanHistory = [];
            initPopulation();
            updateStats();
            addLog('üîÑ Simulation reset');
            
            document.getElementById('allTimeBest').textContent = '0';
            document.getElementById('bestGen').textContent = '1';
            
            gsap.from('.container', { 
                scale: 0.95, 
                rotation: 2,
                duration: 0.5, 
                ease: "elastic.out(1, 0.5)" 
            });
        });

        document.getElementById('spawnLaserBtn').addEventListener('click', () => {
            if (lasers.length < CONFIG.MAX_LASERS * 2) {
                lasers.push(new Laser(canvas.width / 2, canvas.height / 2));
                addLog('üî¥ Manual laser spawned!');
                
                gsap.from('#spawnLaserBtn', { 
                    backgroundColor: '#ff0000',
                    scale: 1.1,
                    duration: 0.3,
                    yoyo: true,
                    repeat: 1
                });
            }
        });

        // Initialize
        initPopulation();
        updateStats();
        drawNeuralNetwork();

        // Start animation loop even when paused (for rendering)
        gameLoop();

        // Welcome animation - wait for DOM to be ready
        window.addEventListener('load', () => {
            gsap.from('.container', {
                opacity: 0,
                y: 50,
                duration: 1,
                ease: "power3.out"
            });

            gsap.from('.stat-item', {
                opacity: 0,
                x: -30,
                duration: 0.8,
                stagger: 0.1,
                ease: "back.out"
            });
        });
    </script>
</body>
</html>
